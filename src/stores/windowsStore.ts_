// import {defineStore} from 'pinia';
// import {ref} from "vue";
// import {useUtils} from "src/services/Utils";
// import PersistenceService from "src/services/PersistenceService";
//
// /**
//  * a pinia store for windows information.
//  *
//  * Elements are persisted to the storage provided in the initialize function
//  */
//
// let storage: PersistenceService = null as unknown as PersistenceService
//
// export const useWindowsStore = defineStore('windows', () => {
//
//     const {inBexMode} = useUtils()
//
//     /**
//      * the map of all 'ever used' Chrome tab groups, even if they are not currently in use,
//      * using the title as key.
//      */
//     const allWindows = ref<Map<number, chrome.windows.Window>>(new Map())
//
//     /**
//      * the array all actually currently used Chrome tab groups.
//      */
//     const currentWindows = ref<chrome.windows.Window[]>([])
//
//     /**
//      * initialize store with
//      * @param ps a persistence storage
//      */
//     async function initialize(providedDb: PersistenceService) {
//         console.log("initializing windowsStore")
//         storage = providedDb
//         init("initialization")
//     }
//
//     function init(trigger: string = "") {
//         if (inBexMode() && chrome?.windows) {
//             chrome.windows.getAll({}, (windows) => {
//
//                 currentWindows.value = windows
//                 console.log("initializing current windows with", currentWindows.value)
//
//                 // adding potentially new groups to storage
//                 const res: Promise<any>[] = windows.flatMap((window: chrome.windows.Window) => {
//                     return storage.addWindow(window)
//                 })
//
//                 // setting all (new and older) groups to 'tabGroups'
//                 Promise.all(res)
//                     .then(() => {
//                         allWindows.value = new Map()
//                         storage.getWindows().then(res => {
//                             res.forEach(r => allWindows.value.set(r.id || 0, r))
//                         })
//                     })
//             })
//         }
//     }
//
//     function onCreated(window: chrome.windows.Window) {
//         console.debug("window: onCreated", window)
//         if (inBexMode() && chrome?.windows) {
//             chrome.windows.getAll({}, (windows) => {
//                 currentWindows.value = windows
//             })
//         }
//     }
//
//     function onUpdated(window: chrome.windows.Window) {
//         console.debug("window: onUpdated", window)
//         if (inBexMode() && chrome?.windows) {
//
//             chrome.windows.getAll({}, (windows) => {
//                 currentWindows.value = windows
//
//                 console.log("set currentWindows to", windows)
//
//                 // update tabGroups
//                 for (const w of windows) {
//                     useWindowsStore().persistWindow(w)
//                 }
//
//                 // update the group names for matching group ids
//                 // for (const ts of [...useTabsStore().tabsets.values()]) {
//                 //     let matchForTabset = false
//                 //     for (const t of ts.tabs) {
//                 //         for (const g of groups) {
//                 //             if (t.groupId === g.id && t.groupName !== g.title) {
//                 //                 console.log("found match", g)
//                 //                 t.groupName = g.title
//                 //                 matchForTabset = true
//                 //             }
//                 //         }
//                 //     }
//                 //     if (matchForTabset) {
//                 //         useTabsetService().saveTabset(ts)
//                 //     }
//                 // }
//
//                 // update color changes
//                 // for (const g of groups) {
//                 //     const tabGroup = findGroup([...tabGroups.value.values()], undefined, g.title)
//                 //     if (tabGroup && tabGroup.color !== g.color) {
//                 //         console.log("updating group", tabGroup, g)
//                 //         storage.updateGroup(g)
//                 //     }
//                 // }
//             })
//         }
//     }
//
//     function initListeners() {
//         if (inBexMode() && chrome && chrome.windows) {
//             chrome.windows.onCreated.addListener((window: chrome.windows.Window) => onCreated(window))
//             chrome.windows.onRemoved.addListener((windowId: number) => init("onRemoved"))
//             chrome.windows.onBoundsChanged.addListener((window: chrome.windows.Window) => init("onBoundsChanged"))
//         }
//     }
//
//     function findGroup(groups: chrome.tabGroups.TabGroup[], groupId: number | undefined, groupName: string | undefined) {
//         if (groupId) {
//             for (const g of groups) {
//                 if (g.id === groupId) {
//                     return g
//                 }
//             }
//         }
//         if (groupName) {
//             for (const g of groups) {
//                 if (g.title === groupName) {
//                     return g
//                 }
//             }
//         }
//         return undefined
//     }
//
//     // function groupForName(groupTitle: string | undefined): chrome.tabGroups.TabGroup | undefined {
//     //     if (inBexMode() && usePermissionsStore().hasFeature(FeatureIdent.TAB_GROUPS) && chrome && chrome.tabGroups && groupTitle) {
//     //         return _.find([...tabGroups.value.values()], g => g.title === groupTitle)
//     //     }
//     //     return undefined
//     // }
//     //
//     // function currentGroupForName(groupName: string | undefined = undefined): chrome.tabGroups.TabGroup | undefined {
//     //     if (inBexMode() && usePermissionsStore().hasFeature(FeatureIdent.TAB_GROUPS) && chrome?.tabGroups && groupName) {
//     //         return findGroup(currentWindows.value, undefined, groupName)
//     //     }
//     //     return undefined
//     // }
//
//     // function currentGroupForId(groupId: number): chrome.tabGroups.TabGroup | undefined {
//     //     if (inBexMode() && usePermissionsStore().hasFeature(FeatureIdent.TAB_GROUPS) && chrome?.tabGroups) {
//     //         return findGroup(currentWindows.value, groupId, undefined)
//     //     }
//     //     return undefined
//     // }
//
//     async function persistWindow(window: chrome.windows.Window) {
//         console.log("persisting window", window)
//         const existingWindows = await storage.getWindows()
//         console.log("got existing windows", existingWindows)
//
//         const index = existingWindows.findIndex(g => {
//             return g.id === window.id
//         })
//         if (index < 0) {
//             // no window exits yet with same id
//             await storage.addWindow(JSON.parse(JSON.stringify(window)) as chrome.windows.Window)
//         } else {
//             const existingWindow = existingWindows[index]
//             console.debug("replacing window", existingWindow, window)
//             //await storage.deleteGroupByTitle(existingGroup.title || '')
//             await persistWindow(window)
//         }
//     }
//
//     // function updateGroup(group: chrome.tabGroups.TabGroup) {
//     //     return storage.updateGroup(group)
//     // }
//     //
//     // function deleteGroupByTitle(title: string) {
//     //     tabGroups.value.delete(title)
//     //     return storage.deleteGroupByTitle(title)
//     // }
//
//     return {
//         initialize,
//         initListeners,
//         currentWindows,
//         persistWindow
//     }
// })
